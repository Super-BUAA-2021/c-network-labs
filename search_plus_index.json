{"./":{"url":"./","title":"实验向导","keywords":"","body":"Introduction Network Labs Guidance 北航软件学院计网实验教程 慕课测试答案：https://blog.csdn.net/qq_40079310/category_9849971.html 指导材料 计算机网络实验 - 中国大学MOOC 网络实验常见问题解答 License Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0). See LICENSE for more info. Copyright © blog.zewan.cc 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-12-06 05:52:20 "},"post/lab1.html":{"url":"post/lab1.html","title":"Lab1 网络实验入门","keywords":"","body":"网络实验入门 作者：蒋博文 1 根据多方调查，基本上没人找出怎么对应的接口，就直接截了display current-configuration 之后的截图(根本就不显示GE那个接口只有E打头和S打头的接口) R1 截图：打开winxp2C ，双击R1.ht ,回车，输入display current-configuration，然后一路 回车可以看更多的信息，截图即可 R2 截图：打开winxp2D 操作同R1 。 2 进入超级终端R1.ht ，刚开始前面是 ,然后敲system-view ，前面变成[R1] ，这是系统视 图；然后敲interface Ethernet 0/0 ，然后前面变成[R1 Ethernet 0/0] ，这是接口视图，然 后输入shutdown关闭，在输入undo shutdown开启，截图即可。 顺便提一句，进入视图之后，想要返回上一级视图用quit命令。 3 打开WireShark->点击本地连接， start->选择filter为http 打开“连线组网软件”->点击“主网联机”->按照如下图操作设为自动连接。 打开“我的电脑”，在目录处输入www.baidu.com ，然后在WireShark双击一条报文进行查看，然后填表就行。 4 观看mooc视频1.6，照着做就行。 5 做了4你就知道5怎么做了 6 没做 7 Copyright © blog.zewan.cc 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-12-06 05:52:20 "},"post/lab2.html":{"url":"post/lab2.html","title":"Lab2 数据链路层实验","keywords":"","body":" author ： 周海涛 IP配置 登录服务器后，先该四个PC机的IP。一定要严格按照下图中的设置，不然后果自负： 同时，清空S1，S2，R1，R2上的所有内容。 先reset saved-xxxx，输入y 再reboot，先输入n，再输入y T1 抓包 打开 wireshark，然后点start即可进行抓包。随便挑一个包截个图，然后按报告里分析下就行。答案是固定的人。 T2 Mac 地址 以下内容在PCA中做。 先在超级终端中看一下Mac地址表： 这里仿照我的报告截个图。 （1） 这里照抄 （2）不能，理由，分析过程照抄。 先清空一下Mac表： 然后display看一眼，真空了。 打开cmd，然后随便ping个什么东西。输入ipconfig/all，看一下PCA的Mac地址。 然后再display看一眼，发现里面多了一个Mac地址，就是PCA的，验证成功。 T3 组网 首先点击桌面上新连线组网，依次点击PCA，PCB，S1按钮。 然后右键PCA 与 S1 选择端口进行连接，PCB同理。连接好后效果如图示： 记得点实验组网->提交。 然后设置S1： 按照表格，进行A ping B,A ping C操作，一个通，一个不通，截图记录。 T4 照抄。 T5 按下图配置： 然后，设置S1，S2，输入如下命令（记得输入两遍，一个交换机一遍）： 这时让A ping C，通，截图记录。同时在PCA上监听一下报文，看icmp类型。截个图。 填表。完全照抄，只需要将源Mac，目标Mac换成PCA 和 PCC 的Mac即可。每个人实验环境不一样，Mac也不一样，记得改。 T6 display 看一下S1上的Mac表。此时会有很多，截图。 找到里面PCA 和PCC的部分，填进去。剩下的随便挑4个放进去即可。字段截图中都有的，慢慢抄。 T9 在PCC 的R1终端中打命令： 稍等一会，会不断输出东西。截两个图放进去，流程图照抄。 T10 经过研究，我手头的报告作者他们都没有打新的命令，直接在T9基础上等了一小会，又截了两个图。我们仿照着做，然后流程图照抄。 链路层实验到此结束。 Copyright © blog.zewan.cc 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-12-06 05:52:20 "},"post/lab3.html":{"url":"post/lab3.html","title":"Lab3 网络层实验","keywords":"","body":"网络层实验 作者：黄泽桓 本实验默认你已进行过入门实验，了解一些基本操作，尽管『jbw-入门教程』十分差劲。 开始实验前，打开超级终端，运行reset save、reboot恢复初始设置，前者直接y，后者先n后y。 ARP报文分析 打开连线组网软件，组网如下，完成后提交。 接着配置PCA和PCB的IP地址。PCA： PCB： 后，依次执行：打开PCA、PCB的cmd，输入arp -a。 题1表格第一部分，即2.6.1中步骤2中的执行结果 输入命令 结果 PCA中arp -a PCB中arp -a 若上述步骤中，结果不是No ARP，则需要输入arp -d清空。 然后打开PCA和PCB的Wireshark，如下图点击配置，注意IP要选择刚刚设置的IP。 PCA和PCB都如上图一样配置，然后打开PCA的cmd窗口，输入ping 192.168.1.21，ping PCB。 后停止PCA和PCB的Wireshark对报文的截获，总体截图(包含ARP+ICMP)用于题2，在PCA中点击第一条和第二条ARP，展开链路层和网络层截图，用于题3。 题2： 答：报文截获结果如下： [截图] 有2个ARP报文，8个ICMP报文，”Opcode“字段值为1代表request，2代表reply 题3： [截图×2]第一条ARP请求报文和第一条ARP应答报文 字段项 ARP请求数据报文 ARP应答数据报文 链路层Destination项 ff:ff:ff:ff:ff:ff 00:0c:29:04:7f:48 链路层Source项 00:0c:29:04:7f:48 00:0c:29:23:dc:f9 网络层Sender MAC Address 00:0c:29:04:7f:48 00:0c:29:23:dc:f9 网络层Sender IP Address 192.168.1.22 192.168.1.21 网络层Target MAC Address 00:00:00:00:00:00 00:0c:29:04:7f:48 网络层Target IP Address 192.168.1.21 192.168.1.22 点击Ctrl+S保存报文信息，保存PCA和PCB的报文，命名为ping1-学号，方便后续分析。 接下来，打开PCA、PCB的cmd，输入arp -a查看。 题1第二部分，即2.6.1中步骤4中的执行结果，填入截图（如果此时arp -a没能出现列表，就再ping一次即可，好像还有时间要求，几次ping不要隔太久） 输入命令 结果 PCA中arp -a PCB中arp -a 之后重新运行PCA和PCB的wireShark，在PCA中ping 192.168.1.21，后停止wireShark并保存报文为ping2-学号。打开ping1和ping2对比，将ping2报文截图，在ping2中filterarp再截图一张。 题4(1)： 答：少了ARP报文。原因是ARP缓存已经保存下了上一次ARP报文的内容，也就是PCB的MAC地址。所以在这一次的ping中，PCA不再需要用ARP询问PCB的MAC地址。ARP缓存可以保存之前收到的ARP回复，减少ARP请求的次数。 [此处要有截图两张] 重新组网连线，组网如下，连接后提交。 设置PCA和PCB的默认网关。PCA： PCB： 题4(2):按照图-4重新进行组网，并确保连线正确。修改计算机的IP地址，并将PC A的默认网关修改为192.168.1.10，PC B的默认网关修改为192.168.2.10。考虑如果不设置默认网关会有什么后果？ 答：如果不设置默认网关，那么PCA ping PCB时发现PCB不在同一局域网后，由于没有默认网关，也就无法交给默认网关转发，最后只能放弃发送，ping不通。 在PCA的超级终端中，输入以下命令设置VLAN2和VLAN3： sys [S1]vlan 2 [S1-vlan2]port e 1/0/1 [S1-vlan2]inter vlan2 [S1-Vlan-interface2]ip add 192.168.1.10 255.255.255.0 [S1-Vlan-interface2]vlan 3 [S1-vlan3]port e 1/0/13 [S1-vlan3]inter vlan3 [S1-Vlan-interface3]ip add 192.168.2.10 255.255.255.0 然后类似上面的部分步骤，打开WireShark，选择本地设置的IP，运行，然后在PCA中ping 192.168.2.22。执行完后，停止PCA和PCB的截获，将报文信息保存为ping3-学号。并在PCA和PCB中分别点击第一条ARP展开链路层和网络层，查看详情并截图。 题5： 答：截获的ARP报文内容如下：PCA请求报文： PCB应答报文： 根据上图报文，填写表格： 字段项 ARP请求数据报文 ARP应答数据报文 链路层Destination项 ff:ff:ff:ff:ff:ff 00:0c:29:3b:50:e1 链路层Source项 00:0c:29:3b:50:e1 3c:8c:40:2a:39:a8 网络层Sender MAC Address 00:0c:29:3b:50:e1 3c:8c:40:2a:39:a8 网络层Sender IP Address 192.168.1.22 192.168.2.10 网络层Target MAC Address 00:00:00:00:00:00 00:0c:29:3b:50:e1 网络层Target IP Address 192.168.1.10 192.168.1.22 此时ARP请求的目标的IP地址为PCA默认网关的地址，而不是PCB的地址。 区别：相同网段下，ARP会直接请求目标的MAC地址；不同网段下，ARP会请求他的默认网关的MAC地址。 相同点：都各有一个ARP请求和应答报文，请求的发送者和应答的接收者都是同一台主机。 在执行完ping后，在PCA和PCB的cmd中输入arp -a，截图，填入第一题第三部分中。 题1第三部分，即2.6.2中步骤3中的执行结果，填入截图 输入命令 结果 PCA中arp -a PCB中arp -a ICMP报文分析 连线组网，提交： 修改PCA的IP： 修改PCB的IP： 打开PCA的终端，输入： sys [S1]vlan 2 [S1-vlan2]port e 1/0/1 [S1-vlan2]inter vlan2 [S1-Vlan-interface2]ip add 10.1.2.1 255.255.255.0 [S1-Vlan-interface2]vlan 3 [S1-vlan3]port e 1/0/23 [S1-vlan3]inter vlan3 [S1-Vlan-interface3]ip add 10.1.3.1 255.255.255.0 接着类似前面，打开wireshark运行，在PCA中ping 10.1.3.10，停止截获并保存，filter“icmp”并截图总体ICMP报文图，并在PCA中截图第一个ICMP发送和回应的详情，进行分析。 题6：共有 8 个ICMP报文 答：以下是PCA截获报文结果： 第一条ICMP回送请求报文： 第一条ICMP回送应答报文： 一共有8个ICMP报文，其中四个为回送请求报文，四个为回送应答报文。 种类字段名：Type，代码字段名：Code。 通过Sequence number (BE) 和Sequence number (LE) 字段可保证回送请求和回送应答报文一一对应。 运行PCA和PCB的wireshark，打开pingtest软件，如下配置，点击发送： 然后看一下报文截获情况，先不要停止，继续使用pingtest软件如下配置和发送：注意这次目标地址是10.1.3.10，和之前不一样。 接着就可以停止截获，保存报文信息，做以下分析： 题7：（第一次pingtest-两个ICMP） 答：PCA报文截获情况如下： 地址掩码请求报文： 地址掩码应答报文： 地址掩码请求报文 地址掩码应答报文 ICMP字段名 字段值 ICMP字段名 字段值 Type 17 Type 18 Code 0 Code 0 Checksum 0xe3ff Checksum 0xe3fe Identifier(BE) 2560(0x0a00) Identifier(BE) 2560(0x0a00) Identifier(LE) 10(0x000a) Identifier(LE) 10(0x000a) Sequence number(BE) 256(0x0100) Sequence number(BE) 256(0x0100) Sequence number(LE) 1(0x0001) Sequence number(LE) 1(0x0001) Address mask 0.0.0.0 Address mask 255.255.255.0 题8：第二次pingtest（第二次pingtest） PCA时间戳请求报文： PCA时间戳应答报文： 地址掩码请求报文 地址掩码应答报文 ICMP字段名 字段值 ICMP字段名 字段值 Type 13 Type 14 Code 0 Code 0 Checksum 0xe7ff Checksum 0xc6f4 Identifier(BE) 2560(0x0a00) Identifier(BE) 2560(0x0a00) Identifier(LE) 10(0x000a) Identifier(LE) 10(0x000a) Sequence number(BE) 256(0x0100) Sequence number(BE) 256(0x0100) Sequence number(LE) 1(0x0001) Sequence number(LE) 1(0x0001) Originate timestamp 0 seconds after midnight UTC Originate timestamp 0 seconds after midnight UTC Receive timestamp 0 seconds after midnight UTC Receive timestamp 15 hours, 29 minutes, 31.709 seconds after midnight UTC Transmit timestamp 0 seconds after midnight UTC Transmit timestamp 15 hours, 29 minutes, 31.709 seconds after midnight UTC ICMP询问报文的作用：ICMP询问报文可以主动与目标主机交换一些必要的信息（例如地址掩码、时间），以达到通信前协商的效果。 类似地，重新运行PCA和PCB的wireshark，然后在PCA中： $ ping 10.1.3.20 $ ping 10.1.4.10 自然是ping不通的，但能截获到报文。同样的保存报文信息。 这里，在新设备上操作，没法像慕课一样能在cmd上就区分开（慕课操作截图如下）。对于新设备，两种情况从PCA上几乎看不出差别，都显示timed out；在PCB上，可以看到ping 10.1.3.20时，交换机发出了arp request报文，请求10.1.3.20主机的MAC地址，但交换机没有给PCA反馈任何信息。而ping 10.1.4.10没有任何反馈信息。 简单解释一下，在PCA上执行 ping 10.1.3.20和ping 10.1.4.10，目的是ping一个可到达网段的不存在的主机，以及ping一个不可达网段上的不存在的主机。希望PCA能够分别收到“主机不可达”和“网络不可达”两种ICMP差错报文。 PCA ping 10.1.3.20，没有收到“主机不可达”的ICMP差错报文，老师认为有安全性和减轻交换机负担两方面的考虑。例如，对于主机扫描等网络攻击行为，逐条回应主机不可达报文，会消耗交换机的资源。同时，回应报文也容易泄露交换机的ip地址，使其容易受到攻击。 因此，交换机只是发送若干arp request报文，在规定的时间段内如果没有收到应答报文，就会丢弃ICMP request报文。并不发送icmp主机不可达报文。 题9： (1) 请比较这两种情况有何不同？ 答：由于实验在新设备进行，两种情况从PCA上几乎看不出差别，都显示timed out；在PCB上，可以看到ping 10.1.3.20时，交换机发出了arp request报文，请求10.1.3.20主机的MAC地址，但交换机没有给PCA反馈任何信息。而ping 10.1.4.10没有任何反馈信息。 在PCA上执行 ping 10.1.3.20和ping 10.1.4.10，目的是ping一个可到达网段的不存在的主机，以及ping一个不可达网段上的不存在的主机。希望PCA能够分别收到“主机不可达”和“网络不可达”两种ICMP差错报文。 (2) 截获了哪种ICMP差错报文？其类型和代码字段值是什么？此报文的ICMP协议部分又分为了几部分？其作用是什么？ 答：新设备中未截获ICMP差错报文。 [截图×2] 此处拿慕课指导视频中的结果做分析，截获ICMP差错报文的类型为目标不可达。 协议的内容有： Type：ICMP报文的类型，这里为3，即为目标不可达； Code：ICMP代码，这里为0，表示网络不可达； Checksum：ICMP校验和，用于做校验； 数据部分：为封装后的不可达的IP报文 取消PCA上的DNS配置，我一开始没配置所以不需要做改动了。新设备由于安全性，默认对tracert命令不回应，所以需要在PCA超级终端中输入以下命令打开响应： [S1]ip ttl-expires enable [S1]ip unreachables enable PCA和PCB启动WireShark截获，在PCA的cmd中执行tracert 10.1.3.10，将PCA截获的报文信息保存，进行分析。 题10： (1) 结合报文内容，简述tracert的工作过程。 答：tracert会先向目标发出一个TTL=1的包，由于包每一次转发都有TTL-=1，因此转发一次后如果没到达目的地，则TTL=0，转发的主机会丢弃这个包，并往发送的主机发出一条ICMP差错控制报文（超时）。发送的主机会根据这个报文获取到途径的路由器的地址。接下来发送的主机再发送一个TTL=2的包，其它操作同上。直到TTL足够大以至于可到达目标，目标将会返回ICMP回送应答报文。 (2) 截获了哪种ICMP差错报文？其类型和代码字段值是什么？ 答：截获ICMP差错报文的类型为超时。Type：11，Code：0。 ICMP差错报文内容： IP报文分析 组网图与前面步骤相同。 题11：根据4.6中步骤1，写出tracert命令用到了IP协议报文的哪几个字段？ 答：Time to live字段。 步骤2 将PCA的子网掩码设置为255.255.0.0，在PCA和PCB启动报文截获，然后PCA ping PCB，即在PCA中输入ping 10.1.3.10。ping不通，截图。 题12：根据4.6中步骤2回答：观察PCA和PCB能否ping通，结合截获报文分析原因。 答：此时PCA会认为PCB和他在同一个网络中，因此会直接发送ARP请求来询问PCB的MAC地址，然而并没有主机回复。因此PCA会放弃发送，ping失败。 步骤3 将PCA的子网掩码恢复为255.255.255.0，执行下列命令查看路由表信息： [H3C]display ip routing-table 截图，填表。 题13： 答：[截图] and 填表 步骤6 按照实验二的5.5节（PPP实验）配置路由器，两个路由器互相ping，看能否ping通。 该步骤对应题14，不建议做，没写步骤，有点复杂，直接抄。放不放截图都可以。 想做的朋友，给你列出教程来了： 实验指导文档教材： 题14： (1) 能ping通。 lkw流程图： zyh流程图： 截图（可放可不放）： R2 ping R1： R1 ping R2： (2) 答：两台路由器能ping通。 因为IPCP会协议IP连接的模块，并分配上网所需的参数。当R2的地址发生了修改，IPCP会重新执行刚才的协商，并最终修改适当的参数，使得两个路由器之间连通，所以能ping得通。 [截图] 网络层分片实验 对应选做题15。自己看做不做。 清空连线组网，即一键还原，然后按下图连线。连接后提交。 根据下图修改四个机子的IP。默认网关不填。 在PCC打开R1超级终端，输入： sys [R1]inter ethernet 0/0 [R1-Ethernet0/0]mtu 100 [R1-Ethernet0/0]ip add 192.192.169.10 255.255.255.0 接着打开PCA-D的WireShark软件，使用前需要先设置一下。 打开preferences后，左侧导航栏展开Protocols，找到IPv4，若Reassemble fragmented..被勾选了的话，要去掉勾选。然后点击apply，再OK。 PCA-PCD都如上操作。然后开始截获。 然后在PCC的R1超级终端中，输入以下命令执行ping： ping -s 300 192.192.169.21 ping -s 300 192.192.169.22 ping -s 300 192.192.169.23 ping -s 300 192.192.169.24 然后到PCB去保存报文信息，实验中要求保存为”fragment-学号“并上传至FTP服务器的”网络实验/网络层实验“目录下，不过老师说不是必须的。——听君一席话 截图报文信息。 题15： (1) 答：ARP 2个，ICMP:Echo 10个，ICMP Reply 5个，IP报文 15个。 (2) 题目中不展示截图了，直接填表。截图见表后。 字段名称 分片序号1 分片序号2 分片序号3 分片序号4 “Identification”字段值 0x000e(14) 0x000e(14) 0x000e(14) 0x000e(14) “Flag”字段值 0x01 0x01 0x01 0x00 “Frame offset”字段值 0 80 160 240 传输的数据量 80bytes 80bytes 80bytes 68bytes VLAN间路由实验 对应题目16，抄 设计型实验 模仿前人做的。 子网的数量：6，子网掩码均为：255.255.255.224，详细情况如下： 序号 网关 主机地址范围 1 202.108.100.33 202.108.100.34 – 202.108.100.62 2 202.108.100.65 202.108.100.66 – 202.108.100.94 3 202.108.100.97 202.108.100.98 – 202.108.100.126 4 202.108.100.129 202.108.100.130 – 202.108.100.158 5 202.108.100.161 202.108.100.162 – 202.108.100.190 6 202.108.100.193 202.108.100.194 – 202.108.100.222 连线组网： 在S1中配置VLAN： vlan 2 port e1/0/1 int vlan 2 ip add 202.108.100.1 27 vlan 3 port e1/0/24 int vlan 3 ip add 202.108.100.225 27 int vlan 1 ip add 211.100.217.193 24 在R1中配置： int GigabitEthernet0/0 ip add 211.100.217.192 24 ip route-static 202.108.100.0 24 211.100.217.193 PCA的IP： IP：202.109.100.34 子网掩码：255.255.255.224 默认网关：202.109.100.33 PCB的IP： IP：202.109.100.222 子网掩码：255.255.255.224 默认网关：202.109.100.193 用PCA来ping 211.100.217.192： 用PCB来ping 211.100.217.192： 符合实验要求。 Copyright © blog.zewan.cc 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-12-06 05:52:20 "},"post/lab5.html":{"url":"post/lab5.html","title":"Lab5 RIP实验","keywords":"","body":"RIP 实验 作者：郝泽钰 实验开始前，清空上一个人的配置（） 四台电脑都要开 实验1 静态路由 连线组网： 配置 S1 sys vlan 2 port e1/0/17 to e1/0/24 in v 1 ip ad 192.168.2.1 255.255.255.0 in v 2 ip ad 192.168.1.1 255.255.255.0 配置 R1 sys in e0/0 ip ad 192.168.1.2 24 展示路由表，截图(R1上)(题1)： di ip r 配置 PCA 的地址： 配置完成后在 R1 超级终端上 ping PCA 发现不同，截图（题1） R1 上添加静态路由，重新打表并截图（题2）： ip rou 192.168.2.0 255.255.255.0 192.168.1.1 di ip r 此时可以 ping 通，截图： 取消静态路由，添加静态路由，重新查表： un ip rou 192.168.2.0 255.255.255.0 192.168.1.1 ip rou 0.0.0.0 0 192.168.1.1 dis ip r 此时仍然可以 ping 通 实验2 RIP 配置， RIPv1 报文结构分析 重新组网： （建议 实验2 之前再次清空配置） （实验2 - 实验6 是连贯的，中间不用清空） 截获报文（PCA）： 在 R1 上配置： rip net 192.168.1.0 在 S1 上配置： rip net 192.168.1.0 net 192.168.2.0 配完后已经抓到包可以分析了，不过先去 R1 上输出路由表并 ping 一下PCA，截个图（题5）： 可以发现多了一条 RIP 协议的路由信息。 回到 PCA查看抓包结果，选 request 截图（题8） 其余的题抄抄抄就完事了 实验3 距离矢量算法分析 重新组网： 在 PCB 上开始截包。 在 S1 上配置： in v 1 ip ad 192.168.2.1 24 in loop 1 ip ad 192.168.1.1 32 rip net 192.168.2.0 net 192.168.1.0 S2: in v 1 ip ad 192.168.3.2 24 rip net 192.168.3.0 R1: in e0/0 ip ad 192.168.2.2 24 in e0/1 ip ad 192.168.3.2 24 rip net 192.168.2.0 net 192.168.3.0 在 PCB 上抓包，找 response： 重新组网，和上图完全一样，用 PCB监听 R1-E0/1 组好后再找一个response截图： （两个 ，Metric 分别是 1 和 2，10题的图） 在 S2 上如下操作： in loop 2 ip add 192.168.4.1 32 rip net 192.168.4.0 net 192.168.3.0 然后分别在R1,S1中执行 dis ip r 截图（11题） 实验4 没有图 所以。。。 实验5 按顺序配置： S1 in vlan 1 rip v 2 rip au md5 rfc2082 buaa 1 in loo 1 rip v 2 rip au md5 rfc2082 buaa 1 S2 in vlan 1 rip v 2 rip au md5 rfc2082 buaa 1 R1 in e0/0 rip v 2 rip au md5 rfc2082 buaa 1 in e0/1 rip v 2 rip au md5 rfc2082 buaa 1 然后去 PCB 抓 RIPv2 的包，截图 实验6 RIP 组网设计实验 困了，没做（） Copyright © blog.zewan.cc 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-12-06 05:52:20 "},"post/lab6.html":{"url":"post/lab6.html","title":"Lab6 传输层实验","keywords":"","body":"传输层实验 作者：周勤、黄泽桓 对于路由器、交换机，实验前都需要先清空设置，下文将不再说明 本次实验大部分在Linux上完成，小部分在Windows上完成 本次实验主要分为四个任务： TCP协议基本分析 滑动窗口机制和窗口侦查机制分析 慢启动、拥塞避免及拥塞处理实验 UDP实验（Winxp） 实验须知 Linux配置IP地址的方法 鼠标右键点击托盘区网络图标，并点击Edit Connections： 点击Add按钮，在IPv4设置中设置IP地址、网关等，然后依次点击Apply和OK： 需要使用对应的配置时，鼠标左键点击托盘区网络图标，再点击Disconnect断开原有连接，然后选择对应的配置进行连接： WireShark预设置 注意，本次实验需要获取到 sequence number 的绝对值，因此需要将 WireShark 默认获取相对值的设置取消掉，具体过程如下： 点击 WireShark 的 Edit，后点击打开preferences，左侧导航栏展开Protocols，找到TCP，若Relative sequence number被勾选了的话，要去掉勾选。然后点击apply，再OK。 虚拟机联网 联网主要是为了将保存的报文文件或其它信息文件传输到本机上，这样方便做完实验后再分析数据。如果希望边做实验边分析数据和截图的话，可以不需要了解本部分。 需要注意的是，建议做完所有Linux实验再联网将实验数据一起发回，这样不用重复连线组网，因为本次Linux上进行的实验组网都一样。 进入PCA的连线组网程序，点击主机联网： 接下来需要使用DHCP获取主机地址，在托盘区点击这个图标，选择Auto_DHCP即可（若没有这个配置，则可以自行配置DHCP）： 配置完之后，可以使用ifconfig命令来进行验证，还可使用ping 10.111.1.29命令来验证与FTP服务器的连通性（对于PCB这样的多网卡机器，可以使用ifconfig eth1 down命令来关闭网卡1，防止网卡1的干扰）： 若使用FTP传输文件，则这时就可以点击托盘区的gFTP图标，打开gFTP程序。 输入FTP服务器的地址，协议选择FTP，点击电脑图标进行连接后，就可以上传到自己的文件夹了： 另外，还可以通过发送邮件（我就是这样干的）等方式将数据发回本机，因为都连接外网了，所以可以乱搞，但是由于配置原因，所以这样可能稍微卡一些。联网记得访问 gw.buaa.edu.cn 登录，这样才能真的上网，另外默认是谷歌搜索引擎，所以建议直接搜网址，或者进百度主页搜索。 实验1：TCP协议基本分析 步骤1 配置路由器和交换机 连接到服务器后，登录Linux虚拟机，用户名root，密码network，在PCA的桌面找到并打开连线组网软件。 由于是Java写的程序，所以跨平台做的比较好，如下图连线组网并且提交即可（连线组网可能比较慢，请耐心等待，如果遇到白屏和打不开等问题，大概率是后端炸了）： 打开PCC配置R1，打开终端输入minicom命令，进入超级终端。 需要注意的是，打开了之后，千万不要关闭monicom终端，不过可以最小化，其他程序也建议不要关 根据如下的命令配置R1的IP地址即可（如果GigabitEthernet用不了，可以用Ethernet）： sys interface GigabitEthernet 0/0 port link-mode route ip address 192.168.1.1 255.255.255.0 interface GigabitEthernet 0/1 port link-mode route ip address 192.168.2.1 255.255.255.0 打开PCA配置S1，同样打开终端输入minicom命令，进入超级终端。 需要注意的是，打开了之后，千万不要关闭monicom终端，不过可以最小化，其他程序也建议不要关 进入超级终端后，需要配置IP地址和两个VLAN，配置命令如下： sys vlan 2 to 3 interface Ethernet 1/0/1 port access vlan 2 interface Ethernet 1/0/2 port access vlan 2 interface Ethernet 1/0/23 port access vlan 3 interface Ethernet 1/0/24 port access vlan 3 在虚拟机中，PCA和PCB的IP地址都已经配好了，只需要在托盘区点击网络图标进行选择并连接即可。PCA需要选择TCP_Sender，PCB需要选择TCP_Receiver： 如果机器没有预先配好，则需要按照Pre中的步骤进行配置，实验组网图如下： 另外，PCB是多网卡机器，若自己配置PCB的IP地址，则建议关闭PCB的网卡1，命令为： ifconfig eth1 down 设置IP后若发现点击网络图标无法显示可连接的网络，则右键点击，勾选 Enable Networking。 都连接好之后可以使用ping命令验证一下连接性，还可以用ifconfig命令验证IP地址的配置。 步骤2 启动Wireshark和TcpTest 在PCB打开Wireshark，监听Eth0口，过滤器填写tcp，点击Apply： 在PCB的桌面打开TcpTest，点击作为接收端，如下图修改配置，然后点击接收： 在PCA中，同样打开并设置Wireshark，打开Wireshark之后，需要在桌面上先运行tcplog_init脚本： 步骤3 报文截图与分析 等待文件发送完毕后，停止PCA和PCB的抓包，保存或截图PCA和PCB的抓包记录。（关于FTP服务器的使用见下文） 保存或截图之后，可以对TCP三次握手，四次挥手，以及中间过程进行分析，并填写实验报告。 步骤4 分析Linux内核数据 在Wireshark停止抓包之后，在PCA的桌面上点击并运行tcplog_read脚本： 然后在PCA的/root目录下，进入TCPLog文件夹，保存或截图如下文件，该文件记录了Linux内核Tcp协议栈的参数。（关于FTP服务器的使用见下文） 保存或截图之后，进行分析并填写实验报告即可： 实验2：滑动窗口机制和窗口侦查机制分析 基本操作与实验1步骤一致，区别在于TcpTest的设置，需要设置休眠时间，如下图所示。 这样获得的数据，与实验1的区别在于，实验2生成的tcpsndwnddata.txt文件中，rcv_wnd接收方窗口会降低，如下图所示。 实验3：慢启动、拥塞避免及拥塞处理实验 即10Mbps转发速率实验和100Kbps转发速率实验，转发速率实验组网和前面相同。 这部分内容，实验指导书讲得比较详细了，这里放几张实验指导书的截图： 继续在PCA和PCB上进行实验即可，如果之前关闭了minicom，则到这一步时可能会出现minicom打不开的问题。 注意： 如果原来进入的是GigabitEthernet接口，则下面的实验也需要进入GigabitEthernet 若遇到TcpTest报错“I/O错误”，重启TcpTest即可 UDP实验 这个实验需要在WindowsXP上进行，所以需要预约WindowsXP： 本实验截图较少，也比较简单做，我的截图如下： Copyright © blog.zewan.cc 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-12-06 05:52:20 "}}